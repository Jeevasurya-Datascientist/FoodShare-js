rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ==================================================================================
    // ðŸ›¡ï¸ SECURITY HELPER FUNCTIONS
    // ==================================================================================

    // --- Authentication Checks ---
    function isAuthenticated() {
      return request.auth != null;
    }

    function isSafeUser() {
        // Safely check accountStatus. If field is missing (new/legacy users), default to safe.
        // We check if the data exists first, then the field.
        let userData = getUserData();
        // If userData is null (doc doesn't exist), we assume safe (allow creation/initial reads) ?? 
        // Actually getUserData().data crashes if doc missing? No, returns null.
        // But safer:
        return userData == null || !('accountStatus' in userData) || (userData.accountStatus != 'banned' && userData.accountStatus != 'suspended');
    }

    // ðŸ”’ ADMIN CHECK
    // Hardcoded email check for the demo strictly matching the frontend logic
    function isAdmin() {
      return isAuthenticated() && (
        request.auth.token.email == 'admin@foodshare.com' || 
        request.auth.token.email == 'admin@timechain.com'
      );
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // --- User Role Checks (if we had custom claims, otherwise relying on profile) ---
    // Note: In a strict prod env, use Custom Claims. specific user docs check:
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    // --- Data Validation Helpers ---
    // Check if the request only updates specific allowed fields
    function onlyUpdates(allowedFields) {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields);
    }

    // Check if a field is being changed
    function isFieldChanged(fieldName) {
      return request.resource.data.diff(resource.data).affectedKeys().hasAny([fieldName]);
    }

    // Check required fields for creating a donation
    function hasRequiredDonationFields() {
      let data = request.resource.data;
      return data.keys().hasAll(['title', 'description', 'foodType', 'quantity', 'location', 'donorId', 'status', 'createdAt'])
             && data.title is string && data.title.size() > 0
             && data.description is string
             && data.foodType is string
             && data.quantity is string
             && data.location.lat is number
             && data.location.lng is number;
    }

    // --- Status Transition Helpers ---
    function isTransition(from, to) {
      return resource.data.status == from && request.resource.data.status == to;
    }

    // ==================================================================================
    // ðŸ“‚ USERS COLLECTION
    // ==================================================================================
    match /users/{userId} {
      // ðŸ“– READ: Publicly readable for authenticated users (required for leaderboard, profiles, chats)
      // BUT blocked for banned/suspended users to prevent "cheat methods" (scoping info)
      // EXCEPTION: Users MUST be able to read their own profile to see their status.
      // EXCEPTION: Admins MUST be able to read all profiles to manage them.
      allow read: if isAuthenticated() && (isOwner(userId) || isSafeUser() || isAdmin());

      // âœï¸ WRITE: Owner only
      allow create: if isOwner(userId);
      
      // ðŸ”„ UPDATE: Owner OR Admin
      allow update: if isAuthenticated() && (
        (isOwner(userId) && isSafeUser()) || 
        isAdmin() || 
        onlyUpdates(['stats'])
      );

      // Inventory Sub-collection (NGOs)
      match /inventory/{itemId} {
        allow read, write: if isOwner(userId) && isSafeUser();
      }
      
      // Saved Recipes Sub-collection
      match /savedRecipes/{recipeId} {
        allow read, write: if isOwner(userId) && isSafeUser();
      }
    }

    // ==================================================================================
    // ðŸ“¦ DONATIONS COLLECTION
    // ==================================================================================
    match /donations/{donationId} {
      
      // ðŸ“– READ: Broad access for functionality
      // BLOCKED for suspended/banned
      allow read: if isAuthenticated() && isSafeUser();

      // âž• CREATE: Only valid donations by the donor
      allow create: if isAuthenticated() && isSafeUser()
                    && request.resource.data.donorId == request.auth.uid
                    && request.resource.data.status == 'pending'
                    && hasRequiredDonationFields();

      // ðŸ”„ UPDATE: Complex State Machine
      allow update: if isAuthenticated() && isSafeUser() && (
        
        // ----------------------------------------------------
        // ðŸ§‘â€ðŸ¤â€ðŸ§‘ SCENARIO 1: DONOR ACTIONS
        // ----------------------------------------------------
        
        // 1.1 Edit Pending Donation (Fix typos before acceptance)
        (
          resource.data.donorId == request.auth.uid &&
          resource.data.status == 'pending' &&
          request.resource.data.donorId == request.auth.uid // Cannot change ownership
        ) ||

        // 1.2 Cancel Donation (Pending -> Cancelled)
        (
          resource.data.donorId == request.auth.uid &&
          isTransition('pending', 'cancelled')
        ) ||

        // ----------------------------------------------------
        // ðŸ¢ SCENARIO 2: NGO ACTIONS
        // ----------------------------------------------------

        // 2.1 Accept Donation (Pending -> Accepted)
        // Must stamp acceptedBy, acceptedByName, acceptedByAddress
        (
          isTransition('pending', 'accepted') &&
          request.resource.data.acceptedBy == request.auth.uid &&
          request.resource.data.acceptedByName is string &&
          // Ideally enforce acceptedByAddress is string if we want to be strict
          (request.resource.data.acceptedByAddress == null || request.resource.data.acceptedByAddress is string)
        ) ||

        // 2.2 Request Volunteer / Update Delivery Status
        // NGO must be the one who accepted it
        (
          resource.data.status == 'accepted' &&
          resource.data.acceptedBy == request.auth.uid &&
          // Allowed changes: deliveryStatus, volunteerId (if unassigning), status (to completed/cancelled)
          (
            isFieldChanged('deliveryStatus') || 
            isTransition('accepted', 'completed') || 
            isTransition('accepted', 'cancelled')
          )
        ) ||

        // ----------------------------------------------------
        // ðŸšš SCENARIO 3: VOLUNTEER ACTIONS
        // ----------------------------------------------------
        
        // 3.1 Self-Assign (Available -> Assigned)
        (
          resource.data.status == 'accepted' &&
          resource.data.deliveryStatus == 'available_for_pickup' &&
          request.resource.data.deliveryStatus == 'assigned' &&
          request.resource.data.volunteerId == request.auth.uid &&
          // Must explicitly set their name/phone
          request.resource.data.volunteerName is string
        ) ||

        // 3.2 Update Logistics (Assigned -> Picked Up -> Delivered)
        (
           resource.data.volunteerId == request.auth.uid &&
           (
             isFieldChanged('deliveryStatus') || 
             // Allow simple message/timestamp updates if needed
             onlyUpdates(['deliveryStatus', 'updatedAt'])
           )
        )
      );

      // ðŸ—‘ï¸ DELETE: Only pending donations by owner
      allow delete: if isAuthenticated() && isSafeUser()
                    && resource.data.donorId == request.auth.uid 
                    && resource.data.status == 'pending';
    }

    // ==================================================================================
    // ðŸ“¢ NOTIFICATIONS COLLECTION
    // ==================================================================================
    match /notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Anyone can create a notification (system events, triggers from other users)
      // In a stricter app, this might be Cloud Function only, but for client-driven apps:
      allow create: if isAuthenticated() 
                    && request.resource.data.userId is string
                    && request.resource.data.message.size() > 0;
      
      // Users can mark read (update) or delete their own
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // ==================================================================================
    // ðŸ’¬ CHATS COLLECTION
    // ==================================================================================
    match /chats/{chatId} {
      // Helper for participant check
      function isParticipant() {
        return request.auth.uid in resource.data.participants;
      }
      
      function isNewParticipant() {
        return request.auth.uid in request.resource.data.participants;
      }

      allow read: if isAuthenticated() && isParticipant();
      
      // Create chat if you are one of the participants
      allow create: if isAuthenticated() 
                    && request.resource.data.participants.size() >= 2
                    && isNewParticipant();
                    
      // Update (e.g., lastMessage, timestamps)
      allow update: if isAuthenticated() && isParticipant();

      // ðŸ“¨ MESSAGES SUB-COLLECTION
      match /messages/{messageId} {
        // Parent chat check is expensive (get), but necessary for security
        function isParentChatParticipant() {
           let chatData = get(/databases/$(database)/documents/chats/$(chatId)).data;
           return request.auth.uid in chatData.participants;
        }

        allow read: if isAuthenticated() && isParentChatParticipant();
        
        allow create: if isAuthenticated() 
                      && isParentChatParticipant()
                      && request.resource.data.senderId == request.auth.uid;
      }
    }

    // ==================================================================================
    // â­ REVIEWS COLLECTION
    // ==================================================================================
    match /reviews/{reviewId} {
      allow read: if isAuthenticated();
      
      // Create: One user reviewing another
      allow create: if isAuthenticated() 
                    && request.resource.data.reviewerId == request.auth.uid
                    && request.resource.data.rating >= 1 
                    && request.resource.data.rating <= 5;
                    
      // Update/Delete: Only the reviewer
      allow update, delete: if isOwner(resource.data.reviewerId);
    }

    // ==================================================================================
    // ðŸš¨ COMPLAINTS COLLECTION
    // ==================================================================================
    match /complaints/{complaintId} {
      // Anyone can report a problem
      allow create: if isAuthenticated() 
                    && request.resource.data.ngoId == request.auth.uid;
                    
      // Only the reporter or an Admin can read/update
      allow read, update: if isAuthenticated() && (
        resource.data.ngoId == request.auth.uid ||
        isAdmin() // Allow admin to see and resolve complaints
      );
    }
    
    // ==================================================================================
    // ðŸ›¡ï¸ DEFAULT DENY
    // ==================================================================================
    // Explicitly deny anything else not matched above
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
